---
title: "Quality of Activity - Appendices"
author: "Michael Szczepaniak"
date: "November 2015"
output: html_document
---

## Appendix A - Excluded Variables

The following code was used to determine which columns had missing data:  

```{r eval=FALSE}

trainFile <- "https://github.com/MichaelSzczepaniak/QualityOfActivityClassifier/raw/master/pml-training.csv"
testFile <- "https://github.com/MichaelSzczepaniak/QualityOfActivityClassifier/raw/master/pml-testing.csv"
rawActitivity <- read.csv(trainFile)

## Creates a data frame with three columns: index, ColumnName and
## FractionMissing.
## index is the column index in df corresponding to ColumnName
## ColumnName is as the name implies: the name the column in df
## FractionMissing is the fraction of values that are missing or NA.
## The closer this value is to 1, the less data the column contains
getFractionMissing <- function(df = rawActitivity) {
    colCount <- ncol(df)
    returnDf <- data.frame(index=1:ncol(df),
                           columnName=rep("undefined", colCount),
                           FractionMissing=rep(-1, colCount),
                           stringsAsFactors=FALSE)
    for(i in 1:colCount) {
        colVector <- df[,i]
        missingCount <- length(which(colVector == "") * 1)
        missingCount <- missingCount + sum(is.na(colVector) * 1)
        returnDf$columnName[i] <- as.character(names(df)[i])
        returnDf$FractionMissing[i] <- missingCount / length(colVector)
    }
    
    return(returnDf)
}

varsDf <- getFractionMissing()
varsDf

```

Base on the output above, the following variables were excluded for two reasons. First, `r round(19216/19622, 2) * 100` % of their values were missing. Second, these same variables did were not populated with values in the testing data set (running *getFractionMissing(pml_testing)*).

kurtosis_roll_belt  
kurtosis_picth_belt  
kurtosis_yaw_belt  
skewness_roll_belt  
skewness_roll_belt.1  
skewness_yaw_belt  
max_roll_belt  
max_picth_belt  
max_yaw_belt  
min_roll_belt  
min_pitch_belt  
min_yaw_belt  
amplitude_roll_belt  
amplitude_pitch_belt  
amplitude_yaw_belt  
var_total_accel_belt  
avg_roll_belt  
stddev_roll_belt  
var_roll_belt  
avg_pitch_belt  
stddev_pitch_belt  
var_pitch_belt  
avg_yaw_belt  
stddev_yaw_belt  
var_yaw_belt  
var_accel_arm  
avg_roll_arm  
stddev_roll_arm  
var_roll_arm  
avg_pitch_arm  
stddev_pitch_arm  
var_pitch_arm  
avg_yaw_arm  
stddev_yaw_arm  
var_yaw_arm  
kurtosis_roll_arm  
kurtosis_picth_arm  
kurtosis_yaw_arm  
skewness_roll_arm  
skewness_pitch_arm  
skewness_yaw_arm  
max_roll_arm  
max_picth_arm  
max_yaw_arm  
min_roll_arm  
min_pitch_arm  
min_yaw_arm  
amplitude_roll_arm  
amplitude_pitch_arm  
amplitude_yaw_arm  
kurtosis_roll_dumbbell  
kurtosis_picth_dumbbell  
kurtosis_yaw_dumbbell  
skewness_roll_dumbbell  
skewness_pitch_dumbbell  
skewness_yaw_dumbbell  
max_roll_dumbbell  
max_picth_dumbbell  
max_yaw_dumbbell  
min_roll_dumbbell  
min_pitch_dumbbell  
min_yaw_dumbbell  
amplitude_roll_dumbbell  
amplitude_pitch_dumbbell  
amplitude_yaw_dumbbell  
var_accel_dumbbell  
avg_roll_dumbbell  
stddev_roll_dumbbell  
var_roll_dumbbell  
avg_pitch_dumbbell  
stddev_pitch_dumbbell  
var_pitch_dumbbell  
avg_yaw_dumbbell  
stddev_yaw_dumbbell  
var_yaw_dumbbell  
kurtosis_roll_forearm  
kurtosis_picth_forearm  
kurtosis_yaw_forearm  
skewness_roll_forearm  
skewness_pitch_forearm  
skewness_yaw_forearm  
max_roll_forearm  
max_picth_forearm  
max_yaw_forearm  
min_roll_forearm  
min_pitch_forearm  
min_yaw_forearm  
amplitude_roll_forearm  
amplitude_pitch_forearm  
amplitude_yaw_forearm  
var_accel_forearm  
avg_roll_forearm  
stddev_roll_forearm  
var_roll_forearm  
avg_pitch_forearm  
stddev_pitch_forearm  
var_pitch_forearm  
avg_yaw_forearm  
stddev_yaw_forearm  
var_yaw_forearm  


## Appendix B - Calculation of Error and Accuracy

The following code was used to calculate the errors and the validation accuracy:  

```{r eval=FALSE}
# LDA calculations of IS error, OOS error and accuracy on final test cases
pred.lda.insample <- predict(mod01.lda, newdata = training)
pred.lda.oosample <- predict(mod01.lda, newdata = testing)
acc.lda.insample <- sum(pred.lda.insample == training$classe) / length(training$classe)
acc.lda.oosample <- sum(pred.lda.oosample == testing$classe) / length(testing$classe)
# predict test cases using LDA
pred.lda.test.cases <- predict(mod01.lda, newdata = test.cases)
validation.acc.lda <- sum(pred.lda.test.cases == correct.validation.responses) /
                      length(correct.validation.responses)

# RPART calculations of IS error, OOS error and accuracy on final test cases
pred.cart.insample <- predict(mod02.cart, newdata = training)
pred.cart.oosample <- predict(mod02.cart, newdata = testing)
acc.cart.insample <- sum(pred.cart.insample == training$classe) / length(training$classe)
acc.cart.oosample <- sum(pred.cart.oosample == testing$classe) / length(testing$classe)
# predict test cases using RPART
pred.cart.test.cases <- predict(mod02.cart, newdata = test.cases)
validation.acc.cart <- sum(pred.cart.test.cases == correct.validation.responses) /
                       length(correct.validation.responses)

# RF calculations of IS error, OOS error and accuracy on final test cases
pred.rf.insample <- predict(mod03.rf, newdata = training)
pred.rf.oosample <- predict(mod03.rf, newdata = testing)
acc.rf.insample <- sum(pred.rf.insample == training$classe) / length(training$classe)
acc.rf.oosample <- sum(pred.rf.oosample == testing$classe) / length(testing$classe)
# predict test cases using Random Forrest
pred.rf.test.cases <- predict(mod03.rf, newdata = test.cases)
validation.acc.rf <- sum(pred.rf.test.cases == correct.validation.responses) /
                     length(correct.validation.responses)

# GBM calculations of IS error, OOS error and accuracy on final test cases
pred.gbm.insample <- predict(mod04.gbm, newdata = training)
pred.gbm.oosample <- predict(mod04.gbm, newdata = testing)
acc.gbm.insample <- sum(pred.gbm.insample == training$classe) / length(training$classe)
acc.gbm.oosample <- sum(pred.gbm.oosample == testing$classe) / length(testing$classe)
# predict test cases using GBM
pred.gbm.test.cases <- predict(mod04.gbm, newdata = test.cases)
validation.acc.gbm <- sum(pred.gbm.test.cases == correct.validation.responses) /
                      length(correct.validation.responses)
```

